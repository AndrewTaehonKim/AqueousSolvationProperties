import collections
import json
import numpy as np
import rdkit.Chem
from rdkit.Chem import AllChem
import scipy.constants
import scipy.optimize
import xtb.interface
import xtb.libxtb
import xtb.utils

loadReferenceStates = lambda REFERENCE_STATES_FILEPATH: json.load(open(REFERENCE_STATES_FILEPATH, 'r'))

REFERENCE_STATES_FILEPATH = '../reference_states.json'
KCALPERMOL_PER_HARTREE = 627.509
ANGSTROM_PER_BOHR = scipy.constants.physical_constants['Bohr radius'][0] / scipy.constants.angstrom
reference_states = loadReferenceStates(REFERENCE_STATES_FILEPATH)

class Molecule:
    # initialize molecule (Lareine & Andrew)
    def __init__(self, smiles):
        self.mol = rdkit.Chem.AddHs(rdkit.Chem.MolFromSmiles(smiles)) # add H atoms to a rdkit.
        self.n = self.mol.GetNumAtoms() # number of atoms in the molecule
        self.min_energy = float('inf')
        # make input variables for xtb
        self.atomic_numbers = []
        self.elements = []
        for atom in self.mol.GetAtoms(): # pulling atom information generated by rdkit
            self.atomic_numbers.append(atom.GetAtomicNum())
            self.elements.append(atom.GetSymbol())
        self.atomic_numbers = np.array(self.atomic_numbers)
        self.formation_energy = {None: [], xtb.utils.Solvent.h2o: []}

    # use scipy L-BFGS to optimize energy (Andrew & Lareine)
    def minimizeEnergy(self, solvent=None):
        AllChem.EmbedMolecule(self.mol)
        AllChem.MMFFOptimizeMolecule(self.mol, maxIters=400)
        conformer = self.mol.GetConformer()
        solution = scipy.optimize.minimize(self.getEnergyGradient,
            np.array([conformer.GetAtomPosition(i) for i in range(self.n)])
                .flatten() / ANGSTROM_PER_BOHR,
            args=(solvent,),
            method='L-BFGS-B',
            jac=True,
            # Convergence Criteria based on ORCA 4.2.1.
            # Tight convergence criteria page 19(51) & 605(634) => https://www.afs.enea.it/software/orca/orca_manual_4_2_1.pdf
            options = {'gtol': 3e-3,'maxiter': 3 * self.n},)
        # print(f"Optimization Runtime: {end - start} seconds after {solution.nit} iterations")
        return solution.x.reshape((self.n, 3)) * ANGSTROM_PER_BOHR, solution.fun

    # the method that scipy.optimize.minimize will try to minimize (used above) (Andrew & Lareine)
    def getEnergyGradient(self, xyz, solvent):
        calculator = xtb.interface.Calculator(xtb.interface.Param.GFN2xTB,
            self.atomic_numbers,
            xyz.reshape(self.n, 3))
        calculator.set_solvent(solvent)
        calculator.set_verbosity(xtb.libxtb.VERBOSITY_MUTED)
        singlepoint = calculator.singlepoint()
        return singlepoint.get_energy(), singlepoint.get_gradient().flatten()

    # calculate energy of solvation and subtract with reference energies (from JSON). (Lareine & Andrew)
    def getFormationEnergy(self,
        solvent=xtb.utils.Solvent.h2o,
        reference_states=reference_states,
        iters=10):
        # TODO: Accommodate for non-Gaussian distributions of reference states
        # TODO: Speed up
        self.formation_energy[solvent] = np.array([self.minimizeEnergy(solvent)[1]
            - sum(num_atoms // 2 * np.random.normal(reference_states[element]['energy'],
                reference_states[element]['stddev'])
            for element, num_atoms in collections.Counter(self.elements).items())
            for _ in range(iters)]) * KCALPERMOL_PER_HARTREE
            # compare with reference states by looping over each element
            # example H2O is comprised of 2H + 1O -> energy -> E_H2 + 1/2 E_O2
        return np.mean(self.formation_energy[solvent]), np.std(self.formation_energy[solvent])

    # calculate hydration energy by subtracting aqueous with vacuum (Andrew & Lareine)
    def getHydrationEnergy(self):
        self.getFormationEnergy(solvent=None)
        """
        # for different calculation method for error => get upper and lower E_hydration by taking max solvent - min vacuum & min solvent - max vacuum
        # max_hydration = (self.solvFormationEnergy+self.solvFormationEnergySTD)-(self.vacFormationEnergy-self.vacFormationEnergySTD)
        # min_hydration = (self.solvFormationEnergy-self.solvFormationEnergySTD)-(self.vacFormationEnergy+self.vacFormationEnergySTD)
        # self.hydrationEnergy = (max_hydration+min_hydration)/2
        # self.hydrationEnergySTD = max_hydration-self.hydrationEnergy
        """
        hydration_energy = self.formation_energy[xtb.utils.Solvent.h2o] - self.formation_energy[None]
        return np.mean(hydration_energy), np.std(hydration_energy)

    # generate the fingerprint (Lareine)
    generateFp = lambda self: np.array(rdkit
        .Chem
        .rdFingerprintGenerator
        .GetRDKitFPGenerator(fpSize=512)
        .GetFingerprint(self.mol), dtype=np.intc)

def smiles_to_properties(SMILES):
    mol = Molecule(SMILES)
    return (mol.minimizeEnergy(),
        mol.getFormationEnergy(),
        mol.getHydrationEnergy(),
        mol.generateFp())
