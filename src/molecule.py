import collections
import json
import numpy as np
import rdkit.Chem
from rdkit.Chem import AllChem
import scipy.constants
import timeit
import xtb.interface
import xtb.libxtb
import xtb.utils

REFERENCE_STATES_FILEPATH = '../reference_states.json'
KCALPERMOL_PER_HARTREE = 627.509
BOHR_RADIUS = scipy.constants.physical_constants['Bohr radius'][0] * 1e10

class Molecule:
    # initialize molecule (Lareine & Andrew)
    def __init__(self, smiles):
        try: # in case smile inputed is not usable
            self.mol = rdkit.Chem.AddHs(rdkit.Chem.MolFromSmiles(smiles)) # add H atoms to a rdkit.
        except Exception as e:
            print(f"Failed to create molecule from SMILES string: {smiles}")
            print(f"Error: {e}")
            self.mol = None
            return 0
        self.smiles = smiles
        self.n = self.mol.GetNumAtoms() # number of atoms in the molecule
        self.min_energy=0
        self.preOptimize() # optimize using basic force field
        # make input variables for xtb
        self.atomic_numbers = []
        self.elements = []
        for atom in self.mol.GetAtoms(): # pulling atom information generated by rdkit
            self.atomic_numbers.append(atom.GetAtomicNum())
            self.elements.append(atom.GetSymbol())
        self.atomic_numbers = np.array(self.atomic_numbers)
        self.params = [xtb.interface.Param.GFN0xTB,
            xtb.interface.Param.GFN1xTB,
            xtb.interface.Param.GFN2xTB]
        self.param_index = 2

    # pre-optimization method using rdkit's built in embed molecule and force field (Lareine)
    def preOptimize(self, force_field=True):
        AllChem.EmbedMolecule(self.mol)
        if force_field is True:
            AllChem.MMFFOptimizeMolecule(self.mol, maxIters=400)
        conformer = self.mol.GetConformer()
        self.xyz = np.array([conformer.GetAtomPosition(i) for i in range(self.n)])

    def minimizeEnergy(self, method='BFGS'):
        # TODO: Use gradient to speed up
        solution = scipy.optimize.minimize(self.getEnergy,
            self.xyz.flatten(),
            method=method)
        while self.param_index < 2:
            self.param_index += 1
            solution = scipy.optimize.minimize(self.getEnergy,
                self.xyz.flatten(),
                method=method)
        return 1 - solution.success

    def getEnergy(self, xyz):
        xyz = xyz.reshape(self.n, 3)
        calculator = xtb.interface.Calculator(self.params[self.param_index],
            self.atomic_numbers,
            xyz)
        calculator.set_verbosity(xtb.libxtb.VERBOSITY_MUTED)
        try:
            energy = calculator.singlepoint().get_energy()
            self.xyz = xyz
            return energy
        except xtb.interface.XTBException:
            if self.param_index > 0:
                self.param_index -= 1
                return self.getEnergy(xyz)
            else:
                raise xtb.interface.XTBException

    # calculate energy of solvation and subtract with reference energies (from JSON). (Lareine & Andrew)
    def getFormationEnergy(self, reference_states=json.load(open(REFERENCE_STATES_FILEPATH, 'r')), solvent=xtb.utils.Solvent.h2o, iterations=10):
        formation_energy_list = []
        for i in range(iterations): # sensitivity analysis
            # optimize geometry in solution multiple times
            self.minimizeEnergy(solvent, randomize=True)
            formation_energy = self.min_energy
            # compare with reference states by looping over each element
            for element, num_atoms in collections.Counter(
                self.elements).items():
                formation_energy -= num_atoms/2 * reference_states[element]['energy']
                # example H2O is comprised of 2H + 1O -> energy -> E_H2 + 1/2 E_O2
            formation_energy_list.append(formation_energy)
        formation_energy_list = np.array(formation_energy_list) * KCALPERMOL_PER_HARTREE
        self.formationEnergy, self.formationEnergySTD = np.mean(formation_energy_list), np.std(formation_energy_list)
        return self.formationEnergy, self.formationEnergySTD

    # calculate hydration energy by subtracting aqueous with vacuum (Andrew & Lareine)
    def getHydrationEnergy(self, iterations=10):
        solvent = xtb.utils.Solvent.h2o
        hydration_energy_list = []
        self.solvFormationEnergy, self.solvFormationEnergySTD = self.formationEnergy, self.formationEnergySTD
        self.vacFormationEnergy, self.vacFormationEnergySTD = self.getFormationEnergy(solvent=None)
        """ # for different calculation method for error => get upper and lower E_hydration by taking max solvent - min vacuum & min solvent - max vacuum
        # max_hydration = (self.solvFormationEnergy+self.solvFormationEnergySTD)-(self.vacFormationEnergy-self.vacFormationEnergySTD)
        # min_hydration = (self.solvFormationEnergy-self.solvFormationEnergySTD)-(self.vacFormationEnergy+self.vacFormationEnergySTD)
        # self.hydrationEnergy = (max_hydration+min_hydration)/2
        # self.hydrationEnergySTD = max_hydration-self.hydrationEnergy
        """
        self.hydrationEnergy = self.solvFormationEnergy - self.vacFormationEnergy
        self.hydrationEnergySTD = np.sqrt(self.solvFormationEnergySTD**2+self.vacFormationEnergySTD**2)
        return self.hydrationEnergy, self.hydrationEnergySTD

    # generate the fingerprint (Lareine)
    def generateFp(self):
      self.RDKFingerprint = np.array(rdkit.Chem.rdFingerprintGenerator
                      .GetRDKitFPGenerator(fpSize=512)
                      .GetFingerprint(self.mol), dtype=np.intc)
      return self.RDKFingerprint

    # print properties of the molecule (Andrew)
    def printProperties(self):
      print(f"SMILES: {self.smiles}")
      print(f"Elements: {self.elements}")
      print(f"xyz coordinates (Angstroms): \n {np.array2string(np.round(self.xyz*ANGSTROM_PER_AU,1))}")
      print(f"Formation Energy vs. Reference: {self.solvFormationEnergy: .1f} +- {self.solvFormationEnergySTD: .1} kcal/mol")
      print(f"Hydration Energy:  {self.hydrationEnergy: .2f} +- {self.hydrationEnergySTD: .1} kcal/mol")
      print(f"RDKFingerprint (512 bits): \n {np.array2string(self.RDKFingerprint)}")
