import collections
import concurrent.futures
import copy
import json
import numpy as np
import rdkit.Chem
from rdkit.Chem import AllChem
import scipy.constants
import scipy.optimize
import xtb.interface
import xtb.libxtb
import xtb.utils

import timeit

loadReferenceStates = lambda REFERENCE_STATES_FILEPATH: json.load(open(REFERENCE_STATES_FILEPATH,
    'r'))

REFERENCE_STATES_FILEPATH = '../reference-states.json'
KCALPERMOL_PER_HARTREE = 627.509
ANGSTROM_PER_BOHR = scipy.constants.physical_constants['Bohr radius'][0] / scipy.constants.angstrom
reference_states = loadReferenceStates(REFERENCE_STATES_FILEPATH)

class Molecule:
    # initialize molecule (Lareine & Andrew)
    def __init__(self, smiles):
        self.mol = rdkit.Chem.AddHs(rdkit.Chem.MolFromSmiles(smiles)) # add H atoms to a rdkit.
        self.n = self.mol.GetNumAtoms() # number of atoms in the molecule
        # make input variables for xtb
        self.atomic_numbers = []
        self.elements = []
        for atom in self.mol.GetAtoms(): # pulling atom information generated by rdkit
            self.atomic_numbers.append(atom.GetAtomicNum())
            self.elements.append(atom.GetSymbol())
        self.atomic_numbers = np.array(self.atomic_numbers)
        self.formation_energy = {None: [], xtb.utils.Solvent.h2o: []}

    # use scipy L-BFGS to optimize energy (Andrew & Lareine)
    def minimizeEnergy(self, solvent=None):
        j = np.random.randint(100)
        print('running minimize energy', j)
        mol = copy.deepcopy(self.mol)
        AllChem.EmbedMolecule(mol)
        AllChem.MMFFOptimizeMolecule(mol, maxIters=400)
        conformer = mol.GetConformer()
        solution = scipy.optimize.minimize(self.getEnergyGradient,
            np.array([conformer.GetAtomPosition(i) for i in range(self.n)])
                .flatten() / ANGSTROM_PER_BOHR,
            args=(solvent,),
            method='L-BFGS-B',
            jac=True,
            # Convergence Criteria based on ORCA 4.2.1.
            # Tight convergence criteria page 19(51) & 605(634) => https://www.afs.enea.it/software/orca/orca_manual_4_2_1.pdf
            options = {'gtol': 3e-3,'maxiter': 3 * self.n},)
        # print(f"Optimization Runtime: {end - start} seconds after {solution.nit} iterations")
        print('ending minimize energy', j)
        return solution.x.reshape((self.n, 3)) * ANGSTROM_PER_BOHR, solution.fun

    # the method that scipy.optimize.minimize will try to minimize (used above) (Andrew & Lareine)
    def getEnergyGradient(self, xyz, solvent):
        calculator = xtb.interface.Calculator(xtb.interface.Param.GFN2xTB,
            self.atomic_numbers,
            xyz.reshape(self.n, 3))
        calculator.set_solvent(solvent)
        calculator.set_verbosity(xtb.libxtb.VERBOSITY_MUTED)
        singlepoint = calculator.singlepoint()
        return singlepoint.get_energy(), singlepoint.get_gradient().flatten()

    # calculate energy of solvation and subtract with reference energies (from JSON). (Lareine & Andrew)
    def getFormationEnergy(self,
        solvent=xtb.utils.Solvent.h2o,
        iters=10):
        # TODO: Speed up
        counter = collections.Counter(self.elements)
        for element in counter:
            counter[element] //= 2
        thread_pool_executor = concurrent.futures.ThreadPoolExecutor(max_workers=3)
        self.formation_energy[solvent] = np.array([thread_pool_executor
            .submit(lambda: self
                .minimizeEnergy(solvent)[1] - sum(sum(np.random.choice(reference_states[element],
                    size=num_atoms,
                    replace=True)) for element, num_atoms in counter.items()))
            .result() for _ in range(iters)]) * KCALPERMOL_PER_HARTREE
        return np.mean(self.formation_energy[solvent]), np.std(self.formation_energy[solvent])


    # calculate hydration energy by subtracting aqueous with vacuum (Andrew & Lareine)
    def getHydrationEnergy(self):
        self.getFormationEnergy(solvent=None)
        """
        # for different calculation method for error => get upper and lower E_hydration by taking max solvent - min vacuum & min solvent - max vacuum
        # max_hydration = (self.solvFormationEnergy+self.solvFormationEnergySTD)-(self.vacFormationEnergy-self.vacFormationEnergySTD)
        # min_hydration = (self.solvFormationEnergy-self.solvFormationEnergySTD)-(self.vacFormationEnergy+self.vacFormationEnergySTD)
        # self.hydrationEnergy = (max_hydration+min_hydration)/2
        # self.hydrationEnergySTD = max_hydration-self.hydrationEnergy
        """
        hydration_energy = self.formation_energy[xtb.utils.Solvent.h2o] - self.formation_energy[None]
        return np.mean(hydration_energy), np.std(hydration_energy)

    # generate the fingerprint (Lareine)
    generateFp = lambda self: np.array(rdkit
        .Chem
        .rdFingerprintGenerator
        .GetRDKitFPGenerator(fpSize=512)
        .GetFingerprint(self.mol), dtype=np.intc)

def smiles_to_properties(SMILES):
    mol = Molecule(SMILES)
    return (mol.minimizeEnergy(),
        mol.getFormationEnergy(),
        mol.getHydrationEnergy(),
        mol.generateFp())

# SMILES = 'CC'
SMILES = "CC(C)(C)[C@H](NC(=O)C(F)(F)F)C(=O)N1C[C@H]2[C@@H]([C@H]1C(=O)N[C@H](C#N)C[C@@H]1CCNC1=O)C2(C)C"
start = timeit.default_timer()
molecule = Molecule(SMILES)
output = smiles_to_properties(SMILES)
end = timeit.default_timer()
print(output)
print('Elapsed time:', end - start)

# 2 iterations: 24 seconds
# 10 iterations: 120 seconds
